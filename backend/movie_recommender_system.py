# -*- coding: utf-8 -*-
"""Movie-recommender-system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12i1ScprJ12dpggFE3_-AMXQFxd-sDJkR
"""

# from google.colab import drive
# drive.mount('/content/drive')

import numpy as np
import pandas as pd

movies = pd.read_csv('/content/tmdb_5000_movies.csv')
credits = pd.read_csv('/content/tmdb_5000_credits.csv')

movies.head()



credits.head()

credits.head(1)['cast'].values

credits.head(1)['crew'].values

movies=movies.merge(credits,on='title')

movies.head()

movies.merge(credits,on='title').shape

movies.info()

movies.shape

credits.shape

movies['original_language'].value_counts()

movies.head()['spoken_languages'].values

"""Columns that would be kept in movies dataset :-


id
keywords
title
overview
genres
release_date(numerical column)

cast
crew







"""

movies=movies[['movie_id','title','overview','genres','release_date','keywords','cast','crew']]

movies.head()

"""from current movies df , new df will be made :- {(movie_id),(title),(tags)}"""

movies.isnull().sum()

movies.dropna(inplace=True)

movies.isnull().sum()

movies.duplicated().sum()

#[{"id": 28, "name": "Action"}, {"id": 12, "name": "Adventure"}, {"id": 14, "name": "Fantasy"}, {"id": 878, "name": "Science Fiction"}]
#['Action','Adventure','Fantasy','SciFi']

import ast
def convert(obj):
  L= []
  for i in ast.literal_eval(obj):
    L.append(i['name'])
  return L

movies['genres']=movies['genres'].apply(convert)

movies.head()

movies.head()['genres'].values

movies['keywords']=movies['keywords'].apply(convert)

movies.head()['keywords'].values

import ast
def convert3(obj):
  L= []
  counter=0
  for i in ast.literal_eval(obj):
    if counter !=3:
      L.append(i['name'])
      counter+=1
    else:
        break



  return L

movies['cast']=movies['cast'].apply(convert3)

movies.head()

movies['crew'][0]

import ast
def fetch_director(obj):
  L= []
  try:
    for i in ast.literal_eval(obj):
      if i['job']=='Director':
          L.append(i['name'])
          break
  except (ValueError, SyntaxError):
      # Handle cases where the string is not a valid literal
      pass # Or you could return a specific value like ['Unknown']
  return L

movies['crew']=movies['crew'].apply(fetch_director)

movies.head()

movies['overview'][0]

movies['overview']=movies['overview'].apply(lambda x:x.split())

movies.head()

movies['overview'].apply(type).value_counts()

movies['release_date'] = movies['release_date'].apply(lambda x: str(x).split('-')[0])

movies.head()

movies['release_date'] = movies['release_date'].apply(lambda x: [x])

movies.head()

# To remove spaces from genres

movies['genres'] = movies['genres'].apply(lambda x:[i.replace(" ","") for i in x])

display(movies['genres'])

movies['keywords'] = movies['keywords'].apply(lambda x:[i.replace(" ","") for i in x])

movies['cast'] = movies['cast'].apply(lambda x:[i.replace(" ","") for i in x])

movies['crew'] = movies['crew'].apply(lambda x:[i.replace(" ","") for i in x])

movies.head()

movies['tags']=movies['overview'] + movies['genres'] + movies['release_date'] + movies['keywords'] + movies['cast'] + movies['crew']

movies.head()

display(movies['tags'])

movies['tags'][0]

movies['tags']=movies['overview'] + movies['genres'] + movies['release_date'] + movies['keywords'] + movies['cast'] + movies['crew']
recommendation = movies[['movie_id','title','tags']]
recommendation['tags']=recommendation['tags'].apply(lambda x:" ".join(x))

recommendation = movies[['movie_id','title','tags']].copy()
recommendation['tags']=recommendation['tags'].apply(lambda x:" ".join(x))

recommendation.head()

recommendation['tags']= recommendation['tags'].apply(lambda x:x.lower())

recommendation.head()

import nltk
from nltk.stem.porter import PorterStemmer
ps=PorterStemmer()

def stem(text):
  y = []
  for i in text.split():
    y.append(ps.stem(i))
  return " ".join(y)

recommendation['tags'] = recommendation['tags'].apply(stem)

recommendation['tags'][0]

recommendation['tags'][1]

"""Vectorization"""

from sklearn.feature_extraction.text import CountVectorizer
cv = CountVectorizer(max_features=5000,stop_words='english')

vectors = cv.fit_transform(recommendation['tags']).toarray()

vectors

vectors[0]

cv.get_feature_names_out()

len(cv.get_feature_names_out())

from sklearn.metrics.pairwise import cosine_similarity

cosine_similarity(vectors)

cosine_similarity(vectors).shape

similarity = cosine_similarity(vectors)

similarity

similarity[0]

list(enumerate(similarity[0]))

sorted(list(enumerate(similarity[0])), reverse=True, key=lambda x:x[1])

sorted(list(enumerate(similarity[0])), reverse=True, key=lambda x:x[1])[1:6]

def recommend(movie):
  movie_index = recommendation[recommendation['title'] == movie].index[0]
  # distances is actually a misnomer, it represents similarity scores
  distances = similarity[movie_index]
  movies_list = sorted(list(enumerate(distances)), reverse=True, key=lambda x:x[1])[1:6]

  for i in movies_list:
    print(recommendation.iloc[i[0]].title)
    print(i[0])

recommend('Avatar')

recommend('Batman Begins')